### 一.文件目录

1. /：

   根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。

2. /bin: /usr/bin: 

   可执行二进制文件的目录，如常用的命令ls、tar、mv、cat等。

3. /boot：

   放置linux系统启动时用到的一些文件，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。

4. /dev：

   存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。

5. /etc：

   系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。

6. /home：

   系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。

7. /lib: /usr/lib: /usr/local/lib：

   系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。

8. /lost+fount：

   系统异常产生错误时，会将一些遗失的片段放置于此目录下。

9. /mnt: /media：

   光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。

10. /opt：

    给主机额外安装软件所摆放的目录。

11. /proc：

    此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等。

12. /root：

    系统管理员root的家目录。

13. /sbin: /usr/sbin: /usr/local/sbin：

   放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能"查看"而不能设置和使用。

14. /tmp：

    一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。

15. /srv：

    服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。

16. /usr：

    应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。

17. /var：

    放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。

### 二.操作命令

#### 1.ls命令

##### (1)命令选项

-  -a (--all)

  显示指定目录（缺省为当前目录）下所有文件，包括隐藏文件与目录

-  -d (--directory)

  显示目录信息，而不是目录下的文件信息

-  -h

  人性化显示容量信息。表示”–human-readable”，单位是k或者M ，比较容易看清楚结果

- -i

  列出文件或目录的索引节点号(inode号)

- -l

  使用长格式显示。显示详细信息，例如是文件还是目录，它的大小、修改日期和时间、文件或目录的名字以及文件的属主和它的权限,是long的缩写

#### 2.mkdir

默认使用mkdir 创建的目录权限是755(rwxr-xr-x) 

##### (1)命令选项

- -m 

  为目录指定访问权限，与chmod类似。

- -p

  如果目录已经存在，则不会有错误提示。若父目录不存在，将会创建父目录。该选项常用于创建级联目录。parents的缩写

- -v

  为每个目录显示提示信息。

##### (2)练习

```shell
#创建目录为pp,权限为读执行
mkdir -m=rx pp
#创建linux和test01文件夹，-p表示没有就创建，不报错
#-v显示创建文件夹过程的提示信息
mkdir -pv linux/test01
```

#### 3.rmdir

该命令只能只能删除空文件夹或者使用-p递归删除空文件夹

#### 4.rm

##### (1)命令选项

- -f：不提示，强制删除文件或目录；
- -i：删除已有文件或目录之前先询问用户；
- -r,-R：递归删除，将指定目录下的所有文件与子目录一并删除；
- -v：显示指令的详细执行过程。

#### 5.mv

##### (1)命令格式

> mv [选项] 源文件或目录 目标文件或目录

##### (2)命令功能

​	视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。

​	当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。

​	当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。

##### (3)命令选项

- -b ：若需覆盖文件，则覆盖前先行备份。 
- -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
- -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
- -u ：若目标文件已经存在，且 source 比较新，才会更新(update)
- -t  ： --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。

##### (4)实例

1. 文件改名

   ```shell
   mv a.txt b.txt
   ```

   将文件a.txt重命名为b.txt

2. 移动文件

   ```shell
   mv a.txt java
   ```

   把a.txt文件移到java文件夹中

3. 将文件移动到目录中

   ```shell
   mv a.txt b.txt c.txt java
   ```

4. 目录的移动

   ```shell
   mv c++ java
   ```

   **如果目录1不存在，将目录1改名为2；否则，将1移动到2中。**

5. 把当前目录的一个子目录里的文件移动到另一个子目录里

   ```
   mv test3/*.txt test5
   ```

#### 6.cp

##### (1)命令格式

```shell
# 用法一：复制一个文件
$ cp [option] src-file target-file

# 用法二：复制多个文件，目标是一个文件夹
$ cp [option] src-file1 src-file2 ... target-directory
```

如果一次复制多个文件的话，target必须是一个文件夹。

##### (2)命令选项

- -p

  保留源文件或目录的属性，包括所有者、所属组、权限与时间

- -r

  递归处理，将指定目录下的文件与子目录一并处理。若源文件或目录的形态，不属于目录或符号链接，则一律视为普通文件处理。

- -p 

  连同属性一起复制，而不是使用默认的属性 

- -d 

  若src-file属于link file，则复制为link file，而非文件本身 

- -a 

  --archive 等同于-prd，常用于**文件备份** 

- -i 

  --interactive 若目标文件以存在，则在覆盖前询问是否覆盖 

- -u --update 

  若**源文件比目标文件新**，则覆盖，否则跳过 

- -f 

  --force 强制复制 

- -s 

  -symbolic-link 复制为符号链接文件，即快捷方式文件，俗称**软连接** 

- -l 

  --link复制为**硬连接**文件

##### (3)实例

1. 备份

   ```shell
   cp -ra test01 test03
   ```

2. 更新

   ```shell
   cp -ru test01 test03
   ```

3. 软连接

   ```shell
   cp -s a.txt a.txt.link
   ```

#### 7.touch

文件创建

创建的文件是**去掉执行权限**(x)的权限，保证系统的安全性

#### 8.cat

##### (1)功能

1. 一次显示整个文件。

   ```shell
   cat filename
   ```

2. 从键盘创建一个文件。

   ```shell
   cat > filename
   ```

   只能创建新文件,不能编辑已有文件.使用**ctr+d**结束输入

3. 将几个文件合并为一个文件。

   ```shell
   cat file1 file2 > file
   ```

##### (2)命令选项

- n 或 –number 

  由 1 开始对所有输出的行数编号

- -b 或 –number

  -nonblank 和 -n 相似，只不过对于空白行不编号

- -s 或 –squeeze-blank 

  当遇到有连续两行以上的空白行，就代换为一行的空白行

- -v 或 –show-nonprinting

##### (3)例子

```shell
#把 linuxfile1 的档案内容加上行号后输入 linuxfile2 这个档案里
cat -n linuxfile1 > linuxfile2
#把 linuxfile1 和 linuxfile2 的档案内容加上行号(空白行不加)之后将内容附加到 linuxfile3 里。
cat -b linuxfile1 linuxfile2 >> linuxfile3
#此为清空/etc/test.txt档案内容
cat /dev/null > /etc/test.txt 
```

在linux shell脚本中我们经常见到类似于cat << EOF的语句，不熟悉的童鞋可能觉得很奇怪：EOF好像是文件的结束符，用在这里起到什么作用？EOF是“end of file”，表示**文本结束符**。

首先必须要说明的是EOF在这里没有特殊的含义，你可以使用FOE或OOO等（当然也不限制在三个字符或大写字符）。可以把EOF替换成其他东西，意思是把内容当作标准输入传给程,结合这两个标识，即可避免使用多行echo命令的方式，并实现多行输出的结果。

1. cat<<EOF

   以EOF输入字符为标准输入结束：

2. cat>filename

   创建文件，并把标准输入输出到filename文件中，以ctrl+d作为输入结束：
   注意：输入时是没有'>'的。

3. cat>filename<<EOF

   以**EOF**作为输入结束，和**ctrl+d**的作用一样：

#### 9.more

​	more功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。

##### (1)命令格式

more [-dlfpcsu ][-num ] [+/ pattern][+ linenum] [file ... ] 

##### (2)命令功能：

more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。

##### (3)命令参数：

- +n     

  从笫n行开始显示

- -n      

  定义屏幕大小为n行

- +/pattern 

  在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示  

- -c       

  从顶部清屏，然后显示

##### (4)常用操作命令

- Enter    向下n行，需要定义。默认为1行

- Ctrl+F   向下滚动一屏

- 空格键  向下滚动一屏

- Ctrl+B  返回上一屏

- =       输出当前行的行号

- ：f     输出文件名和当前行的行号

- V      调用vi编辑器

- !命令   调用Shell，并执行命令 

- q       退出more

##### (5)实例

1. 显示文件中从第3行起的内容

   ```shell
   more +3 a.txt
   ```

2. 实例2.将日志内容设置为每屏显示4行

   ```shell
   more -4 a.txt
   ```

3. 从文件中查找第一个出现"liu"字符串的行，并从该处前两行开始显示输出

   ```shell
   more +/liu a.txt
   ```

4. 当一个目录下的文件内容太多，可以用more来分页显示。这得和管道 | 结合起来

   ```shell
   cat /etc/services | more -5
   ```

#### 10.less

​	less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。 在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup][pagedown] 等按 键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。

##### (1)命令功能

​	less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件

##### (2)命令参数

- -i  忽略搜索时的大小写

- -m  显示类似more命令的百分比

- -N  显示每行的行号

- /字符串：向下搜索“字符串”的功能

- ?字符串：向上搜索“字符串”的功能

- b  向后翻一页

- d  向后翻半页

- u  向前滚动半页

- y  向前滚动一行

- 空格键 滚动一行

- 回车键 滚动一页

- [pagedown]： 向下翻动一页

- [pageup]：   向上翻动一页

##### (3)实例

1. ps查看进程信息并通过less分页显示同时显示行号

   ```shell
   ps -ef | less -N
   ```

2. 浏览多个文件

   ```shell
   less -N a.txt b.txt
   ```

   使用如下命令在多个文件之间切换

   - :p - 浏览前一个文件

   - :n - 浏览下一个文件
   - :e 文件名 打开文件

#### 11.head

##### (1)语法

```sh w
head [-n -k ]... [FILE]...
```

##### (2)例子

1. 默认是显示开头前10行。

   ```shell
   head /etc/passwd
   ```

2. 显示开头前k行。

   ```shell
   head -k /etc/passwd
   head -n k /etc/passwd
   head -n +k /etc/passwd
   ```

3. 除最后k行外，显示剩余所有内容。

   ```shell
   head -n -k /etc/passwd
   ```

#### 12.tail

##### (1)语法

```shell
tail [-n -k ]... [FILE]...
```

##### (2)例子

1. 默认是显示末尾10行。

```shell
tail /etc/passwd
```

2. 显示末尾k行。

```shell
tail -k /etc/passwd
tail -n k /etc/passwd（注意和以下的有+的差别）
tail -n -k /etc/passwd
```

3. 从开头第k行开始输出。

```shell
tail -n +k /etc/passwd
```

**head与tail练习**

```shell
//从第11行開始显示，但不包含最后3行
head -n -3 /etc/passwd |tail -n +11

//显示前20行，但从第11行開始
head -n 20 /etc/passwd |tail -n +11 

//显示除最后3行以外的所有行，但仅仅显示最后10行
head -n -3 /etc/passwd |tail -n 10 

//显示前20行中的后10行
head -n 20 /etc/passwd |tail -n 10 

//从第11行开始显示，但仅仅显示前10行
tail -n +11 /etc/passwd |head -n 10 

//从第11行開始显示，但不包含最后3行
tail -n +11 /etc/passwd |head -n -3

//显示最后13行中的前10行
tail -n 13 /etc/passwd |head -n 10 

//显示最后13行中除末尾的3行以外的前10行
tail -n 13 /etc/passwd |head -n -3
```

#### 13.ln

##### (1)概述

​	当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。例如：

```shell
ln–s /bin/less /usr/local/bin/less
```

这一点类似于Windows下的快捷方式，但又有所不同。

　　-s 是代号（symbolic）的意思。

这里有两点要注意：

1. ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；
2. ln的链接分软链接和硬链接两种，软链接就是ln–s ** **，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接ln** **，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。

##### (2)软链接与硬链接的区别

​	 软链接实际上只是一段文字，里面包含着它所指向的文件的名字，系统看到软链接后自动跳到对应的文件位置处进行处理；相反，硬联接为文件开设一个新的目录项，硬链接与文件原有的名字是平权的，在Linux看来它们是等价的。由于这个原因，硬链接不能连接两个不同文件系统上的文件。

1. 软连接可以跨文件系统，硬连接不可以。实践的方法就是用共享文件把windows下的aa.txt文本文档连接到linux下/root目录下bb,cc . ln -saa.txt /root/bb 连接成功。ln aa.txt/root/bb失败。

2. 关于 I节点的问题。硬连接不管有多少个，都指向的是同一个I节点，会把结点连接数增加，只要结点的连接数不是0，文件就一直存在，不管你删除的是源文件还是连接的文件。只要有一个存在，文件就存在（其实也不分什么源文件连接文件的，因为他们指向都是同一个 I节点）。当你修改源文件或者连接文件任何一个的时候，其他的文件都会做同步的修改。软链接不直接使用i节点号作为文件指针,而是使用文件路径名作为指针。所以删除连接文件对源文件无影响，但是删除源文件，连接文件就会找不到要指向的文件。软链接有自己的inode,并在磁盘上有一小片空间存放路径名.

3. 软连接可以对一个不存在的文件名进行连接。

4. 软连接可以对目录进行连接

##### (3)链接到删除

```shell
rm -rf  symbolic_name    
```

注意: 不是**rm -rf   symbolic_name/** 

#### 10.chmod

​	chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。

​	只能文件的**所属者或root用户**才能使用该功能来改变文件的访问权限。

##### (1)命令格式

1. 使用符号模式

   - u: 用户 ,g: 组, o:其它,a: 所有用户(默认)
   - +:增加权限, - :删除权限, =: 重新分配权限
   - r:读, w:写, x:执行, s:设置用户(或组)的ID号 ,t 设置粘着位(sticky bit)，防止文件或目录被非属主删除

   ```shell
   $ chmod u+x file                　　　   #给file的属主增加执行权限
   $ chmod u=rwx,g=rx,o=x file      #上例的另一种形式
   $ chmod =r file                 　　　　#为所有用户分配读权限
   $ chmod a-wx,a+r   file   　　 　   #同上例
   $ chmod -R u+r directory       　   #递归地给directory目录下所有文件和子目录的属主分配读的权限
   ```

2. 使用数字模式

   我们多数用三位八进制数字的形式来表示权限，第一位指定属主的权限，第二位指定组权限，第三位指定其他用户的权限，每位通过4(读)、2(写)、1(执行)三种数值的和来确定权限。如6(4+2)代表有读写权，7(4+2+1)有读、写和执行的权限。

   还可设置第四位，它位于三位权限序列的前面，第四位数字取值是4，2，1，代表意思如下：

   4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。

   2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。

   1，设置粘着位。

   ```shell
   #给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
   $ chmod 751 file                　　　   
   $ chmod 444 file              　
   #设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。
   $ chmod 4755
   ```

##### (2)命令参数

- -R，--recursive

  可递归遍历子目录，把修改应到目录下所有文件和子目录

#### 11.chgrp，chown 

 **root用户**才能改文件的所属组和所属者。

#### 12.目录的权限

| 权限 | 可进行的操作          |
| ---- | --------------------- |
| r    | ls                    |
| w    | mkdir , rm , mv,rmdir |
| x    | cd                    |

#### 13.find

##### (1)格式

```shell
find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;
```

path: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。
-print： find命令将匹配的文件输出到标准输出。
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \;，注意{ }和\；之间的空格。
-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。

-print 将查找到的文件输出到标准输出

-exec   command   {} \;      —–将查到的文件执行command操作,{} 和 \;之间有空格

-ok 和-exec相同，只不过在操作前要询用户

##### (2)参数

```shell
-name   filename             #查找名为filename的文件
-user    username             #按文件属主来查找
-group groupname            #按组来查找
-mtime   -n +n                #按文件更改时间来查找文件，-n指n天以内，+n指n天以前
-atime    -n +n               #按文件访问时间来查GIN: 0px">
-ctime    -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前
-newer   f1 !f2               #查更改时间比f1新但比f2旧的文件
-type    b/d/c/p/l/f         #查是块设备、目录、字符设备、管道、符号链接、普通文件
-size      n[c]               #查长度为n块[或n字节]的文件512kb 0.5M
-mount                       #查文件时不跨越文件系统mount点
```

#### 14.grep

##### (1)常用格式

> grep  [选项]  ”模式“  [文件]

##### (2)常用选项

- -E ：开启扩展（Extend）的正则表达式。

- -i ：忽略大小写（ignore case）。
- -v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。
- -n ：显示行号　　
- -w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker　　
- -c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。
- -o ：只显示被模式匹配到的字符串。
- --color :将匹配到的内容以颜色高亮显示。
- -A  n：显示匹配到的字符串所在的行及其后n行，after
- -B  n：显示匹配到的字符串所在的行及其前n行，before
- -C  n：显示匹配到的字符串所在的行及其前后各n行，context

```shell
#查找all.txt文件是yyy的行的前后两行的值
grep -nC 2 'yyy' all.txt
```

##### (3)模式部分

1. 直接输入要匹配的字符串，这个可以用fgrep（fast grep）代替来提高查找速度，比如我要匹配一下hello.c文件中printf的个数：grep  -c  "printf"  hello.c

2. 使用**基本正则表达式**，下面谈关于基本正则表达式的使用：

   **匹配字符：**

   　　. ：任意一个字符。

   　　[abc] ：表示匹配一个字符，这个字符必须是abc中的一个。

   　　[a-zA-Z] ：表示匹配一个字符，这个字符必须是a-z或A-Z这52个字母中的一个。

   　　[^123] ：匹配一个字符，这个字符是除了1、2、3以外的所有字符。

   　　对于一些常用的字符集，系统做了定义：

   　　[A-Za-z] 等价于 [[:alpha:]]

   　　[0-9] 等价于 [[:digit:]]

   　　[A-Za-z0-9] 等价于 [[:alnum:]]

   　　tab,space 等空白字符 [[:space:]]

   　　[A-Z] 等价于 [[:upper:]]

   　　[a-z] 等价于 [[:lower:]]

   　　标点符号 [[:punct:]]

#### 15.which

​	which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

```shell
which ls
```

#### 16.whereis

whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）

#### 17.help

可以帮助显示命令的用法

```
help cd 
help if
help while
```

